/* eslint-disable no-unused-vars */
// eslint-disable-next-line no-unused-vars
/* eslint-disable react/prop-types */
/* eslint-disable react/no-unknown-property */

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import  { useEffect, useRef, useState } from "react";
import { useGLTF, useAnimations, PerspectiveCamera } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import models from '../assets/3d assets/model.glb'
const color = new THREE.Color();

export default function Model({ scroll, ...props }) {
  const group = useRef();
  const { nodes, materials, animations } = useGLTF(models);
  const { actions } = useAnimations(animations, group);
  const [hovered, set] = useState();
  const extras = {
    receiveShadow: true,
    castShadow: true,
    "material-envMapIntensity": 0.2,
  };
  useEffect(() => void (actions["CameraAction.005"].play().paused = true), []);
  useEffect(() => {
    if (hovered)
      group.current.getObjectByName(hovered).material.color.set("white");
    document.body.style.cursor = hovered ? "pointer" : "auto";
  }, [hovered]);
 useFrame((state) => {
  // Calculate a time value based on the elapsed time, which loops every few seconds
  const elapsedTime = state.clock.getElapsedTime();
  const loopTime = (Math.sin(elapsedTime) + 1) / 2; // Loops between 0 and 1 smoothly

  // Set the time of the camera animation based on loopTime instead of scroll
  actions["CameraAction.005"].time = loopTime * actions["CameraAction.005"].getClip().duration;

  group.current.children[0].children.forEach((child, index) => {
    // Animate color and position in a loop
    child.material.color.lerp(
      color.set(hovered === child.name ? "tomato" : "#202020"),
      hovered ? 0.1 : 0.05
    );

    // Apply looping animations to position and rotation
    child.position.y = Math.sin((elapsedTime + index * 2) / 2) * 1;
    child.rotation.x = Math.sin((elapsedTime + index * 2) / 3) / 10;
    child.rotation.y = Math.cos((elapsedTime + index * 2) / 2) / 10;
    child.rotation.z = Math.sin((elapsedTime + index * 2) / 3) / 10;
  });
});

  return (
    <group ref={group} {...props} dispose={null}>
      <group
        onPointerOver={(e) => (e.stopPropagation(), set(e.object.name))}
        onPointerOut={(e) => (e.stopPropagation(), set(null))}
        position={[0.06, 4.04, 0.35]}
        scale={[0.25, 0.25, 0.25]}
      >
        <mesh
          name="Headphones"
          geometry={nodes.Headphones.geometry}
          material={materials.M_Headphone}
          {...extras}
        />
        <mesh
          name="Notebook"
          geometry={nodes.Notebook.geometry}
          material={materials.M_Notebook}
          {...extras}
        />
        <mesh
          name="Rocket003"
          geometry={nodes.Rocket003.geometry}
          material={materials.M_Rocket}
          {...extras}
        />
        <mesh
          name="Roundcube001"
          geometry={nodes.Roundcube001.geometry}
          material={materials.M_Roundcube}
          {...extras}
        />
        <mesh
          name="Table"
          geometry={nodes.Table.geometry}
          material={materials.M_Table}
          {...extras}
        />
        <mesh
          name="VR_Headset"
          geometry={nodes.VR_Headset.geometry}
          material={materials.M_Headset}
          {...extras}
        />
        <mesh
          name="Zeppelin"
          geometry={nodes.Zeppelin.geometry}
          material={materials.M_Zeppelin}
          v
        />
      </group>
      <group
        name="Camera"
        position={[-1.78, 2.04, 23.58]}
        rotation={[1.62, 0.01, 0.11]}
      >
        <PerspectiveCamera
          makeDefault
          far={100}
          near={0.1}
          fov={28}
          rotation={[-Math.PI / 2, 0, 0]}
        >
          <directionalLight
            castShadow
            position={[10, 20, 15]}
            shadow-camera-right={8}
            shadow-camera-top={8}
            shadow-camera-left={-8}
            shadow-camera-bottom={-8}
            shadow-mapSize-width={1024}
            shadow-mapSize-height={1024}
            intensity={2}
            shadow-bias={-0.0001}
          />
        </PerspectiveCamera>
      </group>
    </group>
  );
}

useGLTF.preload(models);

